#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir>

BUILD_DIR=$1
CACHE_DIR=$2

TEXLIVE_DOMAIN="https://heroku-buildpack-tex.s3.amazonaws.com"
VERSION=`curl $TEXLIVE_DOMAIN/VERSION -s`
TEXLIVE_URL="$TEXLIVE_DOMAIN/texlive-$VERSION.tar.gz"
TEXLIVE_HOME=$BUILD_DIR/.texlive
TEXLIVE_CACHE=$CACHE_DIR/.texlive
PATH=$TEXLIVE_HOME/bin/x86_64-linux:$PATH
DOCUMENT="document.tex"

# Prepare the TeX Live location
[ ! -d $TEXLIVE_HOME ] && mkdir -p $TEXLIVE_HOME

if [ -f $TEXLIVE_CACHE/VERSION ] && (( $VERSION == `cat $TEXLIVE_CACHE/VERSION` )); then
    # Get TeX Live from the cache if possible
    echo "       Installing TeX Live $VERSION from cache"
    cp -R $TEXLIVE_CACHE/* $TEXLIVE_HOME
else
    # Get TeX Live from S3 if necessary
    if [ -f $TEXLIVE_CACHE/VERSION ]; then
        echo "       Upgrading to TeX Live $VERSION"
    else
        echo "       Fetching TeX Live $VERSION"
    fi

    curl $TEXLIVE_URL -s -o - | tar xzf - -C $TEXLIVE_HOME

    # Store a copy of it in the cache so it doesn't have to be fetched again
    [ ! -d $TEXLIVE_CACHE ] && mkdir -p $TEXLIVE_CACHE
    # Make sure the cache is empty first
    rm -rf $TEXLIVE_CACHE/*
    cp -R $TEXLIVE_HOME/* $TEXLIVE_CACHE

    # Store the version for later
    echo $VERSION > $TEXLIVE_CACHE/VERSION
fi

# Download other packages
curl "http://mirrors.med.harvard.edu/ctan/macros/latex/contrib/titlesec/titletoc.sty" -o $TEXLIVE_HOME/texmf-dist/tex/latex/tools/

# Check for an essential binary to make sure it's installed
if [ ! `which pdflatex` ]; then
    echo " !     TeX Live installation failed"
    exit 1
fi

# Check for the existence of a suitable TeX document
cd $BUILD_DIR
if [ ! -f $DOCUMENT ]; then
    echo " !     $DOCUMENT not found." && exit 1
fi

# Convert any fonts that were found
if [ -d $BUILD_DIR/fonts ] && [ "$(ls $BUILD_DIR/fonts)" ]; then
    echo "-----> Converting fonts"
    cd $BUILD_DIR/fonts

    ENC=T1-WGL4.enc
    # TODO: Move this into the distribution, where we'll be able to do this
    # cp $TEXLIVE_HOME/texlive/texmf/fonts/enc/ttf2pk/base/$ENC .
    # Otherwise, we have to do this:
    curl $TEXLIVE_DOMAIN/$ENC -s -O

    # Reset the font map
    echo > ttfonts.map

    # Process TrueType fonts
    if [ "$(ls *.ttf)" ]; then
        for FONT in `ls *.ttf`; do
            # This is *really* unweidly, but it does the job
            NAME=`ttfdump -t name $FONT | sed -e '/NameID:\s*1$/,/>/!d' | grep '>' | sed 's/.*> \(\S*\)/\1/' | sed -n '1p'`
            echo "       $NAME"
            ttf2tfm $FONT -q -T $ENC &> /dev/null
            BASE=`echo $FONT | sed 's/\(.*\?\)\.ttf/\1/'`
            echo "$BASE $FONT Encoding=$ENC" >> ttfonts.map
            FD_FILE="t1$BASE.fd"
            echo "\ProvidesFile{t1$BASE.fd}[$NAME Font]" > $FD_FILE
            echo "\DeclareFontFamily{T1}{$BASE}{}" >> $FD_FILE
            echo "\DeclareFontShape{T1}{$BASE}{m}{n}{ <-> $BASE}{}" >> $FD_FILE
        done
    fi

    # Process OpenType fonts
    if [ "$(ls *.otf)" ]; then
        for FONT in `ls *.otf`; do
            NAME=`otfinfo -a $FONT`
            echo "       $NAME"
            otftotfm -e $ENC $FONT $NAME &> /dev/null
            BASE=`echo $FONT | sed 's/\(.*\?\)\.otf/\1/'`
            echo "$BASE $FONT Encoding=$ENC" >> ttfonts.map
            FD_FILE="t1$BASE.fd"
            echo "\ProvidesFile{t1$BASE.fd}[$NAME Font]" > $FD_FILE
            echo "\DeclareFontFamily{T1}{$BASE}{}" >> $FD_FILE
            echo "\DeclareFontShape{T1}{$BASE}{m}{n}{ <-> $BASE}{}" >> $FD_FILE
        done
    fi
fi

cd $BUILD_DIR

# Attempt to build the document into a PDF
echo "-----> Building $DOCUMENT"
pdflatex --interaction=nonstopmode -file-line-error $DOCUMENT > output.log
WRITTEN=`grep "^Output written" output.log`

# Bail out if something went wrong
if [ ! "$WRITTEN" ]; then
    LOG_FILE=`echo $DOCUMENT | sed 's/\.tex$/.log/'`
    grep "^\./$DOCUMENT:" $LOG_FILE | sed 's/^[^:]\+://' > errors.log
    while read -r line; do
        LINE_NO=`echo $line | cut -d: -f1`
        if [ "$LINE_NO" = "$PREV_LINE_NO" ]; then
            # Ignore multiple messages per line
            continue
        fi
        PREV_LINE_NO="$LINE_NO"
        ERROR=`echo $line | sed "s/^$LINE_NO: //"`

        if [ "$LINE_NO" ]; then
            # Get the actual line in the document that contains the error
            LINE=`sed -n "$LINE_NO p" $DOCUMENT`

            # Send feedback to the user
            echo " !     $ERROR"
            echo "$(printf %6d $LINE_NO) $LINE"
        fi
    done < errors.log
    exit 1
fi

# Give some feedback to the user
OUTPUT_FILENAME=`echo $WRITTEN | sed 's/.*on \(.\+pdf\).*/\1/'`
PAGES=`echo $WRITTEN | sed 's/.* .\([0-9]\+ pages\?\),.*/\1/'`
echo "       Wrote $PAGES to $OUTPUT_FILENAME"
